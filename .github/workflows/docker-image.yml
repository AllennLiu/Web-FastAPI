name: FastAPI CI Deployment

on:
  push:
    branches: [ main, staging ]
    paths-ignore:
      - '**/README.md'
  pull_request:
    branches: [ main, staging ]
    paths:
      - '!README.md'

env:
  ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
  SRV_PASS:     ${{ secrets.SRV_PASS }}
  SRV_USER:     root
  SRV_PORT:     22
  SRV_IP:       10.99.104.214;10.99.104.219;10.99.104.241;10.99.104.250
  WORK_PATH:    /srv/deploy
  MOUNT_PORT:   8787
  MOUNT_PATH_1: /mnt/storage
  MOUNT_PATH_2: /mnt/tmp

jobs:

  # build:
  #   runs-on: self-hosted
  #   container:
  #     image: ghcr.io/allennliu/docker:18
  #     credentials:
  #       username: ${{ github.actor }}
  #       password: ${{ secrets.ACCESS_TOKEN }}
  #   steps:
  #   - uses: actions/checkout@v2
  #   - name: Set Environ Variables
  #     run: |
  #       echo "REPO_AUTHOR=$(echo $GITHUB_REPOSITORY | awk '{print tolower($0)}')" >> $GITHUB_ENV
  #       echo "VERSION=$(grep -E '^`Rev:\s' README.md | grep -oE '([0-9]+\.){2}[0-9]+')" >> $GITHUB_ENV
  #   - name: Build Image
  #     run: |
  #       docker build --no-cache -t ghcr.io/${REPO_AUTHOR}:$VERSION .
  #       docker images | grep -i $GITHUB_REPOSITORY || true
  #   - name: Publish to Registry
  #     run: |
  #       echo $ACCESS_TOKEN | docker login ghcr.io -u $GITHUB_REPOSITORY_OWNER --password-stdin
  #       docker push ghcr.io/${REPO_AUTHOR}:$VERSION

  # staging:
  #   runs-on: self-hosted
  #   needs: build
  #   container:
  #     image: ghcr.io/allennliu/tool-ansible:1.0.1
  #     credentials:
  #       username: ${{ github.actor }}
  #       password: ${{ secrets.ACCESS_TOKEN }}
  #   steps:
  #   - uses: actions/checkout@v2
  #   - name: Set Environ Variables
  #     run: |
  #       echo "VERSION=$(grep -E '^`Rev:\s' README.md | grep -oE '([0-9]+\.){2}[0-9]+')" >> $GITHUB_ENV
  #       echo "PROJECT_NAME=$(basename $GITHUB_REPOSITORY)" >> $GITHUB_ENV
  #       echo "CONTAINER_NAME=$(basename $GITHUB_REPOSITORY | awk '{print tolower($0)}')" >> $GITHUB_ENV
  #       echo "REGISTRY_IMAGE=ghcr.io/$(echo $GITHUB_REPOSITORY | awk '{print tolower($0)}')" >> $GITHUB_ENV
  #       echo "EXE_PATH=${WORK_PATH}/$(basename $GITHUB_REPOSITORY)" >> $GITHUB_ENV
  #   - name: Configure Hosts
  #     if: contains('refs/heads/main', github.ref)
  #     run: |
  #       sed -i "s,<SRV_USER>,${SRV_USER},g" ${PWD}/hosts
  #       sed -i "s,<SRV_PASS>,${SRV_PASS},g" ${PWD}/hosts
  #       sed -i "s,<SRV_PORT>,${SRV_PORT},g" ${PWD}/hosts
  #       sed -i "s,<SRV_IP>,${SRV_IP},g"     ${PWD}/hosts
  #       sed -i -E "s,\;,\n,g"               ${PWD}/hosts
  #   - name: Configure Ansible
  #     run: |
  #       exe_cmd="bash start.sh -v $VERSION -p $PROJECT_NAME -n $CONTAINER_NAME -i $REGISTRY_IMAGE -P $MOUNT_PORT -M1 $MOUNT_PATH_1 -M2 $MOUNT_PATH_2"
  #       sed -i "s,<EXE_CMD>,${exe_cmd},g"     ${PWD}/variables/common.yaml
  #       sed -i "s,<VERSION>,${VERSION},g"     ${PWD}/variables/common.yaml
  #       sed -i "s,<WORK_PATH>,${WORK_PATH},g" ${PWD}/variables/common.yaml
  #       sed -i "s,<EXE_PATH>,${EXE_PATH},g"   ${PWD}/variables/common.yaml
  #       sed -i "s,<SRV_USER>,${SRV_USER},g"   ${PWD}/variables/common.yaml
  #       sed -i "s,<SRV_PASS>,${SRV_PASS},g"   ${PWD}/variables/common.yaml
  #       sed -i "s,<SRV_PORT>,${SRV_PORT},g"   ${PWD}/variables/common.yaml
  #       sed -i "s,<ACCESS_TOKEN>,${ACCESS_TOKEN},g"     ${PWD}/variables/common.yaml
  #       sed -i "s,<REGISTRY_IMAGE>,${REGISTRY_IMAGE},g" ${PWD}/variables/common.yaml
  #       sed -i "s,<CONTAINER_NAME>,${CONTAINER_NAME},g" ${PWD}/variables/common.yaml
  #       sed -i "s,<GITHUB_REPOSITORY_OWNER>,${GITHUB_REPOSITORY_OWNER},g" ${PWD}/variables/common.yaml
  #   - name: Deploy Staging Service
  #     if: contains('refs/heads/staging', github.ref)
  #     run: ansible-playbook -i ${PWD}/hosts deploy-staging.yaml

  #   # Because of the IT domain resolve policy, we couldn't
  #   # pulling image from Github directly on Kubernetes node.
  #   # So this is going to archive image and then pass it to
  #   # deployment Kubernetes node. finally, loading image to
  #   # local Docker image instantly.
  #   - name: Pass Image to Production Server
  #     if: contains('refs/heads/main', github.ref)
  #     run: ansible-playbook -i ${PWD}/hosts passing-image.yaml

  # production:
  #   runs-on: self-hosted
  #   needs: staging
  #   if: contains('refs/heads/main', github.ref)
  #   container:
  #     image: ghcr.io/allennliu/tool-kubectl-deployment:1.0.4
  #     credentials:
  #       username: ${{ github.actor }}
  #       password: ${{ secrets.ACCESS_TOKEN }}
  #   steps:
  #   - uses: actions/checkout@v2
  #   - name: Set Environ Variables
  #     run: |
  #       echo "VERSION=$(grep -E '^`Rev:\s' README.md | grep -oE '([0-9]+\.){2}[0-9]+')" >> $GITHUB_ENV
  #       echo "PROJECT_NAME=$(basename $GITHUB_REPOSITORY)" >> $GITHUB_ENV
  #       echo "CONTAINER_NAME=$(basename $GITHUB_REPOSITORY | awk '{print tolower($0)}')" >> $GITHUB_ENV
  #       echo "REGISTRY_IMAGE=ghcr.io/$(echo $GITHUB_REPOSITORY | awk '{print tolower($0)}')" >> $GITHUB_ENV
  #       echo "EXE_PATH=${WORK_PATH}/$(basename $GITHUB_REPOSITORY)" >> $GITHUB_ENV
  #   - name: Configure Hosts
  #     run: |
  #       sed -i "s,<SRV_USER>,${SRV_USER},g" ${PWD}/hosts
  #       sed -i "s,<SRV_PASS>,${SRV_PASS},g" ${PWD}/hosts
  #       sed -i "s,<SRV_PORT>,${SRV_PORT},g" ${PWD}/hosts
  #       sed -i "s,<SRV_IP>,${SRV_IP},g"     ${PWD}/hosts
  #       sed -i -E "s,\;,\n,g"               ${PWD}/hosts
  #   - name: Deploy Production Service
  #     run: |
  #       bash start.sh --k8s-run -v $VERSION -p $PROJECT_NAME -n $CONTAINER_NAME \
  #         -i $REGISTRY_IMAGE -MP $MOUNT_PORT -M1 $MOUNT_PATH_1 -M2 $MOUNT_PATH_2

  pytest:
    runs-on: self-hosted
    #needs: production
    if: contains('refs/heads/main', github.ref)
    container:
      image: ghcr.io/allennliu/tool-kubectl-deployment:1.0.4
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.ACCESS_TOKEN }}
    steps:
    - uses: actions/checkout@v2
    - name: Set Environ Variables
      run: |
        echo "BRANCH=$(echo $GITHUB_REF | awk -F\/ '{print $2"_"$3}')" >> $GITHUB_ENV
        echo "PROJECT_NAME=$(basename $GITHUB_REPOSITORY)" >> $GITHUB_ENV
        echo "CONTAINER_NAME=$(basename $GITHUB_REPOSITORY | awk '{print tolower($0)}')" >> $GITHUB_ENV
    - name: Run Unit Test
      run: |
        export POD=$(kubectl get pods -n kube-ops | grep -oE "^${CONTAINER_NAME}-(\w+\-)?\w+" | head -n1)
        echo -e "\nStarting run Pytest on pod: ${POD}..\n"
        kubectl exec -t $POD -n kube-ops -- bash -c 'cd tests && pytest' | tee pytest.log
        kubectl exec -t $POD -n kube-ops -- bash -c 'cd tests && cat report.xml' > report.xml
        echo "COVERAGE=$(grep -Eo '^TOTAL.+?([0-9]+\%)$' pytest.log | awk '{print $NF}')" >> $GITHUB_ENV
    - name: Upload Pytest Report
      if: always()
      uses: actions/upload-artifact@v2
      with:
        name: pytest-results
        path: report.xml
    - name: Create Test Coverage Badge
      if: always()
      uses: schneegans/dynamic-badges-action@v1.0.0
      with:
        auth: ${{ secrets.GIST_SECRET }}
        gistID: cdc11bececff228f66cebd39b8b588dc
        filename: ${{ env.PROJECT_NAME }}__${{ env.BRANCH }}.json
        label: Test Coverage
        message: ${{ env.COVERAGE }}
        color: green
        namedLogo: pytest

  # clean:
  #   runs-on: self-hosted
  #   if: always()
  #   needs: [build, production, pytest]
  #   container:
  #     image: ghcr.io/allennliu/docker:18
  #     credentials:
  #       username: ${{ github.actor }}
  #       password: ${{ secrets.ACCESS_TOKEN }}
  #   steps:
  #   - uses: actions/checkout@v2
  #   - name: Clean Environment
  #     run: sh tools/pipeline_clean.sh